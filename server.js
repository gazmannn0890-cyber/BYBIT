// server.js - Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ ÑÐµÑ€Ð²ÐµÑ€
const express = require('express');
const WebSocket = require('ws');
const sqlite3 = require('sqlite3').verbose();
const { BybitAPI } = require('./bybit-api');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());
app.use(express.static('.'));

// Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Bybit API
const bybit = new BybitAPI();

// Ð‘Ð°Ð·Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ…
const db = new sqlite3.Database('./bvbit.db');

// Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹ Ð¿Ñ€Ð¸ Ð·Ð°Ð¿ÑƒÑÐºÐµ
db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE,
    email TEXT UNIQUE,
    password_hash TEXT,
    balance_rub REAL DEFAULT 0,
    balance_usdt REAL DEFAULT 0,
    balance_btc REAL DEFAULT 0,
    balance_eth REAL DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);
  
  db.run(`CREATE TABLE IF NOT EXISTS transactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    type TEXT, -- 'exchange', 'deposit', 'withdraw'
    from_currency TEXT,
    to_currency TEXT,
    from_amount REAL,
    to_amount REAL,
    rate REAL,
    fee REAL,
    status TEXT DEFAULT 'pending',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(user_id) REFERENCES users(id)
  )`);
  
  db.run(`CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT
  )`);
});

// API Routes
app.get('/api/stats', async (req, res) => {
  try {
    const stats = await getPlatformStats();
    res.json(stats);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/users', (req, res) => {
  db.all(`SELECT * FROM users ORDER BY created_at DESC`, (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.get('/api/transactions', (req, res) => {
  const limit = parseInt(req.query.limit) || 50;
  db.all(`
    SELECT t.*, u.username 
    FROM transactions t 
    LEFT JOIN users u ON t.user_id = u.id 
    ORDER BY t.created_at DESC 
    LIMIT ?
  `, [limit], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

// Bybit Ñ†ÐµÐ½Ñ‹
app.get('/api/prices', async (req, res) => {
  try {
    const prices = await bybit.getTickers();
    res.json(prices);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ð—Ð°Ð¿ÑƒÑÐº ÑÐµÑ€Ð²ÐµÑ€Ð°
app.listen(PORT, () => {
  console.log(`ðŸš€ BVBIT Server running on port ${PORT}`);
  console.log(`ðŸ“Š Admin panel: http://localhost:${PORT}/admin.html`);
  console.log(`ðŸ’± Exchange: http://localhost:${PORT}/index.html`);
});

// WebSocket Ð´Ð»Ñ Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ñ… Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹
const wss = new WebSocket.Server({ port: 8080 });
wss.on('connection', (ws) => {
  console.log('WebSocket client connected');
  
  // ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ ÐºÐ°Ð¶Ð´Ñ‹Ðµ 5 ÑÐµÐºÑƒÐ½Ð´
  const interval = setInterval(async () => {
    try {
      const prices = await bybit.getTickers();
      const stats = await getPlatformStats();
      
      ws.send(JSON.stringify({
        type: 'update',
        prices,
        stats
      }));
    } catch (error) {
      console.error('WebSocket error:', error);
    }
  }, 5000);
  
  ws.on('close', () => {
    clearInterval(interval);
    console.log('WebSocket client disconnected');
  });
});

async function getPlatformStats() {
  return new Promise((resolve, reject) => {
    db.get(`
      SELECT 
        COUNT(*) as total_users,
        SUM(balance_rub) as total_volume_rub,
        SUM(balance_usdt) as total_volume_usdt,
        (SELECT COUNT(*) FROM transactions WHERE status = 'completed') as total_transactions,
        (SELECT SUM(fee) FROM transactions WHERE status = 'completed') as total_fees
      FROM users
    `, (err, row) => {
      if (err) reject(err);
      else resolve(row);
    });
  });
}
